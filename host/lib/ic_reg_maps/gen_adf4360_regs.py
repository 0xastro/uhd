#!/usr/bin/env python
#
# Copyright 2008,2009 Free Software Foundation, Inc.
# 
# This file is part of GNU Radio
# 
# GNU Radio is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either asversion 3, or (at your option)
# any later version.
# 
# GNU Radio is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GNU Radio; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 51 Franklin Street,
# Boston, MA 02110-1301, USA.

import re
import os
import sys
from Cheetah.Template import Template
def parse_tmpl(_tmpl_text, **kwargs):
    return str(Template(_tmpl_text, kwargs))
def safe_makedirs(path):
    not os.path.isdir(path) and os.makedirs(path)

########################################################################
# Template for raw text data describing registers
# name addr[bit range inclusive] default optional enums
########################################################################
REGS_DATA_TMPL="""\
########################################################################
## address 0
########################################################################
core_power_level         0[2:3]     0          5ma, 10ma, 15ma, 20ma
counter_operation        0[4]       0          normal, reset
muxout_control           0[5:7]     0          3state, dld, ndiv, dvdd, rdiv, nchan_od_ld, sdo, dgnd
phase_detector_polarity  0[8]       0          neg, pos
charge_pump_output       0[9]       0          normal, 3state
cp_gain_0                0[10]      0          set1, set2
mute_till_ld             0[11]      0          dis, enb
output_power_level       0[12:13]   0          3_5ma, 5_0ma, 7_5ma, 11_0ma
#set $current_setting_enums = ', '.join(map(lambda x: x+"ma", "0_31 0_62 0_93 1_25 1_56 1_87 2_18 2_50".split()))
current_setting1         0[14:16]   0          $current_setting_enums
current_setting2         0[17:19]   0          $current_setting_enums
power_down               0[20:21]   0          normal_op=0, async_pd=1, sync_pd=3
prescaler_value          0[22:23]   0          8_9, 16_17, 32_33
########################################################################
## address 2
########################################################################
a_counter                2[2:6]     0
b_counter                2[8:20]    0
cp_gain_1                2[21]      0          set1, set2
divide_by_2_output       2[22]      0          fund, div2
divide_by_2_prescaler    2[23]      0          fund, div2
########################################################################
## address 1
########################################################################
r_counter                1[2:15]    0
ablpw                    1[16:17]   0           3_0ns, 1_3ns, 6_0ns
lock_detect_precision    1[18]      0           3cycles, 5cycles
test_mode_bit            1[19]      0
band_select_clock_div    1[20:21]   0           1, 2, 4, 8
"""

########################################################################
# Header and Source templates below
########################################################################
HEADER_TEXT="""
#import time

/***********************************************************************
 * This file was generated by $file on $time.strftime("%c")
 **********************************************************************/

\#ifndef INCLUDED_ADF4360_REGS_HPP
\#define INCLUDED_ADF4360_REGS_HPP

\#include <boost/cstdint.hpp>

struct adf4360_regs_t{
#for $reg in $regs
    #if $reg.get_enums()
    enum $(reg.get_name())_t{
        #for $i, $enum in enumerate($reg.get_enums())
        #set $end_comma = ',' if $i < len($reg.get_enums())-1 else ''
        $(reg.get_name().upper())_$(enum[0].upper()) = $enum[1]$end_comma
        #end for
    } $reg.get_name();
    #else
    boost::$reg.get_stdint_type() $reg.get_name();
    #end if
#end for

    adf4360_regs_t(void){
#for $reg in $regs
        $reg.get_name() = $reg.get_default();
#end for
    }

    enum addr_t{
        ADDR_CONTROL = 0,
        ADDR_NCOUNTER = 2,
        ADDR_RCOUNTER = 1
    };

    boost::uint32_t get_reg(addr_t addr){
        boost::uint32_t reg = addr & 0x3;
        switch(addr){
        #for $addr in (0, 1, 2)
        case $addr:
            #for $reg in filter(lambda r: r.get_addr() == addr, $regs)
            reg |= (boost::uint32_t($reg.get_name()) & $reg.get_mask()) << $reg.get_shift();
            #end for
            break;
        #end for
        }
        return reg;
    }
};

\#endif /* INCLUDED_ADF4360_REGS_HPP */
"""

class reg:
    def __init__(self, reg_des):
        x = re.match('^(\w*)\s*(\w*)\[(.*)\]\s*(\w*)\s*(.*)$', reg_des)
        name, addr, bit_range, default, enums = x.groups()

        #store variables
        self._name = name
        self._addr = int(addr)
        if ':' in bit_range: self._addr_spec = map(int, bit_range.split(':'))
        else: self._addr_spec = int(bit_range), int(bit_range)
        self._default = int(default)

        #extract enum
        self._enums = list()
        if enums:
            enum_val = 0
            for enum_str in map(str.strip, enums.split(',')):
                if '=' in enum_str:
                    enum_name, enum_val = enum_str.split('=')
                    enum_val = int(enum_val)
                else: enum_name = enum_str
                self._enums.append((enum_name, enum_val))
                enum_val += 1

    def get_addr(self): return self._addr
    def get_enums(self): return self._enums
    def get_name(self): return self._name
    def get_default(self):
        for key, val in self.get_enums():
            if val == self._default: return str.upper('%s_%s'%(self.get_name(), key))
        return self._default
    def get_stdint_type(self):
        if self.get_bit_width() <=  8: return 'uint8_t'
        if self.get_bit_width() <= 16: return 'uint16_t'
        if self.get_bit_width() <= 32: return 'uint32_t'
        if self.get_bit_width() <= 64: return 'uint64_t'
        raise Exception, 'too damn big'
    def get_shift(self): return self._addr_spec[0]
    def get_mask(self): return hex(int('1'*self.get_bit_width(), 2))
    def get_bit_width(self): return self._addr_spec[1] - self._addr_spec[0] + 1

if __name__ == '__main__':
    regs = map(reg, parse_tmpl(REGS_DATA_TMPL).splitlines())
    safe_makedirs(os.path.dirname(sys.argv[1]))
    open(sys.argv[1], 'w').write(parse_tmpl(HEADER_TEXT, regs=regs, file=__file__))
