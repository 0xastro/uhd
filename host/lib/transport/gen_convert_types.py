#!/usr/bin/env python
#
# Copyright 2010 Ettus Research LLC
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

TMPL_TEXT = """
#import time
/***********************************************************************
 * This file was generated by $file on $time.strftime("%c")
 **********************************************************************/

\#include <uhd/config.hpp>
\#include <uhd/transport/convert_types.hpp>
\#include <boost/cstdint.hpp>
\#include <boost/detail/endian.hpp>
\#include <stdexcept>
\#include "convert_types_impl.hpp"

using namespace uhd;

/***********************************************************************
 * Generate predicate for jump table
 **********************************************************************/
UHD_INLINE boost::uint8_t get_pred(
    const io_type_t &io_type,
    const otw_type_t &otw_type,
    size_t num_chans
){
    boost::uint8_t pred = 0;

    switch(otw_type.byteorder){
    \#ifdef BOOST_BIG_ENDIAN
    case otw_type_t::BO_BIG_ENDIAN:    pred |= $ph.nswap_p; break;
    case otw_type_t::BO_LITTLE_ENDIAN: pred |= $ph.bswap_p; break;
    \#else
    case otw_type_t::BO_BIG_ENDIAN:    pred |= $ph.bswap_p; break;
    case otw_type_t::BO_LITTLE_ENDIAN: pred |= $ph.nswap_p; break;
    \#endif
    case otw_type_t::BO_NATIVE:        pred |= $ph.nswap_p; break;
    default: throw std::runtime_error("unhandled otw byteorder type");
    }

    switch(otw_type.get_sample_size()){
    case sizeof(boost::uint32_t): pred |= $ph.item32_p; break;
    default: throw std::runtime_error("unhandled otw sample size");
    }

    switch(io_type.tid){
    case io_type_t::COMPLEX_FLOAT32: pred |= $ph.fc32_p; break;
    case io_type_t::COMPLEX_INT16:   pred |= $ph.sc16_p; break;
    default: throw std::runtime_error("unhandled io type id");
    }

    switch(num_chans){
    case 1: pred |= $ph.chan1_p; break;
    case 2: pred |= $ph.chan2_p; break;
    case 3: pred |= $ph.chan3_p; break;
    case 4: pred |= $ph.chan4_p; break;
    default: throw std::runtime_error("unhandled number of channels");
    }

    return pred;
}

/***********************************************************************
 * Convert host type to device type
 **********************************************************************/
void transport::convert_io_type_to_otw_type(
    const std::vector<const void *> &io_buffs,
    const io_type_t &io_type,
    void *otw_buff,
    const otw_type_t &otw_type,
    size_t nsamps_per_io_buff
){
    switch(get_pred(io_type, otw_type, io_buffs.size())){
    #for $pred in range(2**$ph.nbits)
    case $pred:
        #set $out_type = $ph.get_dev_type($pred)
        #set $in_type = $ph.get_host_type($pred)
        #set $num_chans = $ph.get_num_chans($pred)
        #set $converter = '_'.join([$in_type, 'to', $out_type])
        #if $num_chans == 1
        $(converter)_$ph.get_swap_type($pred)(
            reinterpret_cast<const $(in_type)_t *>(io_buffs.front()),
            reinterpret_cast<$(out_type)_t *>(otw_buff),
            nsamps_per_io_buff
        );
        #else
        for (size_t i = 0; i < nsamps_per_io_buff; i++){
            #for $j in range($num_chans)
            reinterpret_cast<$(out_type)_t *>(otw_buff)[i*$num_chans + $j] =
                #if $ph.get_swap_type($pred) == 'bswap'
                uhd::byteswap($(converter)(reinterpret_cast<const $(in_type)_t *>(io_buffs[$j])[i]));
                #else
                $(converter)(reinterpret_cast<const $(in_type)_t *>(io_buffs[$j])[i]);
                #end if
            #end for
        }
        #end if
        break;
    #end for
    }
}

/***********************************************************************
 * Convert device type to host type
 **********************************************************************/
void transport::convert_otw_type_to_io_type(
    const void *otw_buff,
    const otw_type_t &otw_type,
    std::vector<void *> &io_buffs,
    const io_type_t &io_type,
    size_t nsamps_per_io_buff
){
    switch(get_pred(io_type, otw_type, io_buffs.size())){
    #for $pred in range(2**$ph.nbits)
    case $pred:
        #set $out_type = $ph.get_host_type($pred)
        #set $in_type = $ph.get_dev_type($pred)
        #set $num_chans = $ph.get_num_chans($pred)
        #set $converter = '_'.join([$in_type, 'to', $out_type])
        #if $num_chans == 1
        $(converter)_$ph.get_swap_type($pred)(
            reinterpret_cast<const $(in_type)_t *>(otw_buff),
            reinterpret_cast<$(out_type)_t *>(io_buffs.front()),
            nsamps_per_io_buff
        );
        #else
        for (size_t i = 0; i < nsamps_per_io_buff; i++){
            #for $j in range($num_chans)
            reinterpret_cast<$(out_type)_t *>(io_buffs[$j])[i] =
                #if $ph.get_swap_type($pred) == 'bswap'
                $(converter)(uhd::byteswap(reinterpret_cast<const $(in_type)_t *>(otw_buff)[i*$num_chans + $j]));
                #else
                $(converter)(reinterpret_cast<const $(in_type)_t *>(otw_buff)[i*$num_chans + $j]);
                #end if
            #end for
        }
        #end if
        break;
    #end for
    }
}

"""

def parse_tmpl(_tmpl_text, **kwargs):
    from Cheetah.Template import Template
    return str(Template(_tmpl_text, kwargs))

class ph:
    bswap_p  = 0b00001
    nswap_p  = 0b00000
    item32_p = 0b00000
    sc16_p   = 0b00010
    fc32_p   = 0b00000
    chan1_p  = 0b00000
    chan2_p  = 0b00100
    chan3_p  = 0b01000
    chan4_p  = 0b01100

    nbits = 4 #see above

    @staticmethod
    def has(pred, mask, flag): return (pred & mask) == flag

    @staticmethod
    def get_swap_type(pred):
        mask = 0b1
        if ph.has(pred, mask, ph.bswap_p): return 'bswap'
        if ph.has(pred, mask, ph.nswap_p): return 'nswap'
        raise NotImplementedError

    @staticmethod
    def get_dev_type(pred):
        mask = 0b0
        if ph.has(pred, mask, ph.item32_p): return 'item32'
        raise NotImplementedError

    @staticmethod
    def get_host_type(pred):
        mask = 0b10
        if ph.has(pred, mask, ph.sc16_p): return 'sc16'
        if ph.has(pred, mask, ph.fc32_p): return 'fc32'
        raise NotImplementedError

    @staticmethod
    def get_num_chans(pred):
        mask = 0b1100
        if ph.has(pred, mask, ph.chan1_p): return 1
        if ph.has(pred, mask, ph.chan2_p): return 2
        if ph.has(pred, mask, ph.chan3_p): return 3
        if ph.has(pred, mask, ph.chan4_p): return 4
        raise NotImplementedError

if __name__ == '__main__':
    import sys
    open(sys.argv[1], 'w').write(parse_tmpl(TMPL_TEXT, file=__file__, ph=ph))
