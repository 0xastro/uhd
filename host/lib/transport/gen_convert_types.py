#!/usr/bin/env python
#
# Copyright 2010 Ettus Research LLC
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

TMPL_TEXT = """
#import time
/***********************************************************************
 * This file was generated by $file on $time.strftime("%c")
 **********************************************************************/

\#include <uhd/config.hpp>
\#include <uhd/transport/convert_types.hpp>
\#include <uhd/utils/byteswap.hpp>
\#include <boost/cstdint.hpp>
\#include <boost/detail/endian.hpp>
\#include <stdexcept>
\#include <complex>

//define the endian macros to convert integers
\#ifdef BOOST_BIG_ENDIAN
    \#define BE_MACRO(x) x
    \#define LE_MACRO(x) uhd::byteswap(x)
    static const bool is_big_endian = true;
\#else
    \#define BE_MACRO(x) uhd::byteswap(x)
    \#define LE_MACRO(x) x
    static const bool is_big_endian = false;
\#endif

using namespace uhd;

/***********************************************************************
 * Constants
 **********************************************************************/
typedef std::complex<float>          fc32_t;
typedef std::complex<boost::int16_t> sc16_t;
typedef boost::uint32_t              item32_t;

static const float shorts_per_float = float(32767);
static const float floats_per_short = float(1.0/shorts_per_float);

/***********************************************************************
 * Single-sample converters
 **********************************************************************/
template<typename outptr_type, typename inptr_type>
static UHD_INLINE outptr_type conv_ptr(inptr_type inptr){
    return reinterpret_cast<outptr_type>(inptr);
}

static UHD_INLINE item32_t sc16_to_item32(sc16_t num){
    return *conv_ptr<item32_t*>(&num);
}

static UHD_INLINE sc16_t item32_to_sc16(item32_t item){
    return *conv_ptr<sc16_t*>(&item);
}

static UHD_INLINE item32_t fc32_to_item32(fc32_t num){
    return sc16_to_item32(sc16_t(
        boost::int16_t(num.real()*shorts_per_float),
        boost::int16_t(num.imag()*shorts_per_float)
    ));
}

static UHD_INLINE fc32_t item32_to_fc32(item32_t item){
    sc16_t num = item32_to_sc16(item); return fc32_t(
        float(num.real()*floats_per_short),
        float(num.imag()*floats_per_short)
    );
}

/***********************************************************************
 * Sample-buffer converters
 **********************************************************************/
UHD_INLINE boost::uint8_t get_pred(
    const io_type_t &io_type,
    const otw_type_t &otw_type
){
    boost::uint8_t pred = 0;

    switch(otw_type.byteorder){
    case otw_type_t::BO_BIG_ENDIAN:    pred |= $ph.be_p; break;
    case otw_type_t::BO_LITTLE_ENDIAN: pred |= $ph.le_p; break;
    ##let the compiler determine the native byte order (we could use python sys.byteorder)
    case otw_type_t::BO_NATIVE:        pred |= (is_big_endian)? $ph.be_p : $ph.le_p; break;
    default: throw std::runtime_error("unhandled byteorder type");
    }

    switch(otw_type.width){
    case 16: pred |= $ph.w16_p; break;
    default: throw std::runtime_error("unhandled bit width");
    }

    switch(io_type.tid){
    case io_type_t::COMPLEX_INT16:   pred |= $ph.sc16_p; break;
    case io_type_t::COMPLEX_FLOAT32: pred |= $ph.fc32_p; break;
    default: throw std::runtime_error("unhandled io type id");
    }

    return pred;
}

void transport::convert_io_type_to_otw_type(
    const void *io_buff, const io_type_t &io_type,
    void *otw_buff, const otw_type_t &otw_type,
    size_t num_samps
){
    switch(get_pred(io_type, otw_type)){
    #for $pred in range(4)
    case $pred:
        #set $out_type = $ph.get_dev_type($pred)
        #set $in_type = $ph.get_host_type($pred)
        #set $converter = $in_type+"_to_"+$out_type
        #set $xe_macro = $ph.get_xe_macro($pred)
        for (size_t i = 0; i < num_samps; i++){
            (($(out_type)_t *)otw_buff)[i] = $(xe_macro)($(converter)(((const $(in_type)_t *)io_buff)[i]));
        }
        break;
    #end for
    }
}

void transport::convert_otw_type_to_io_type(
    const void *otw_buff, const otw_type_t &otw_type,
    void *io_buff, const io_type_t &io_type,
    size_t num_samps
){
    switch(get_pred(io_type, otw_type)){
    #for $pred in range(4)
    case $pred:
        #set $out_type = $ph.get_host_type($pred)
        #set $in_type = $ph.get_dev_type($pred)
        #set $converter = $in_type+"_to_"+$out_type
        #set $xe_macro = $ph.get_xe_macro($pred)
        for (size_t i = 0; i < num_samps; i++){
            (($(out_type)_t *)io_buff)[i] = $(converter)($(xe_macro)(((const $(in_type)_t *)otw_buff)[i]));
        }
        break;
    #end for
    }
}

"""

def parse_tmpl(_tmpl_text, **kwargs):
    from Cheetah.Template import Template
    return str(Template(_tmpl_text, kwargs))

class ph:
    be_p   = 0b00001
    le_p   = 0b00000
    w16_p  = 0b00000
    sc16_p = 0b00010
    fc32_p = 0b00000

    @staticmethod
    def get_xe_macro(pred):
        if (pred & ph.be_p) == ph.be_p: return 'BE_MACRO'
        if (pred & ph.le_p) == ph.le_p: return 'LE_MACRO'
        raise NotImplementedError

    @staticmethod
    def get_dev_type(pred):
        if (pred & ph.w16_p) == ph.w16_p: return 'item32'
        raise NotImplementedError

    @staticmethod
    def get_host_type(pred):
        if (pred & ph.sc16_p) == ph.sc16_p: return 'sc16'
        if (pred & ph.fc32_p) == ph.fc32_p: return 'fc32'
        raise NotImplementedError

if __name__ == '__main__':
    import sys
    open(sys.argv[1], 'w').write(parse_tmpl(TMPL_TEXT, file=__file__, ph=ph))
