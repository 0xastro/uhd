#!/usr/bin/env python
#
# Copyright 2010 Ettus Research LLC
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

TMPL_TEXT = """
#import time
/***********************************************************************
 * This file was generated by $file on $time.strftime("%c")
 **********************************************************************/

\#include <uhd/config.hpp>
\#include <uhd/transport/convert_types.hpp>
\#include <boost/cstdint.hpp>
\#include <boost/detail/endian.hpp>
\#include <stdexcept>
\#include "convert_types_impl.hpp"

using namespace uhd;

/***********************************************************************
 * Generate predicate for jump table
 **********************************************************************/
UHD_INLINE boost::uint8_t get_pred(
    const io_type_t &io_type,
    const otw_type_t &otw_type
){
    boost::uint8_t pred = 0;

    switch(otw_type.byteorder){
    \#ifdef BOOST_BIG_ENDIAN
    case otw_type_t::BO_BIG_ENDIAN:    pred |= $ph.nswap_p; break;
    case otw_type_t::BO_LITTLE_ENDIAN: pred |= $ph.bswap_p; break;
    \#else
    case otw_type_t::BO_BIG_ENDIAN:    pred |= $ph.bswap_p; break;
    case otw_type_t::BO_LITTLE_ENDIAN: pred |= $ph.nswap_p; break;
    \#endif
    case otw_type_t::BO_NATIVE:        pred |= $ph.nswap_p; break;
    default: throw std::runtime_error("unhandled otw byteorder type");
    }

    switch(otw_type.get_sample_size()){
    case sizeof(boost::uint32_t): pred |= $ph.item32_p; break;
    default: throw std::runtime_error("unhandled otw sample size");
    }

    switch(io_type.tid){
    case io_type_t::COMPLEX_FLOAT32: pred |= $ph.fc32_p; break;
    case io_type_t::COMPLEX_INT16:   pred |= $ph.sc16_p; break;
    default: throw std::runtime_error("unhandled io type id");
    }

    return pred;
}

/***********************************************************************
 * Convert host type to device type
 **********************************************************************/
void transport::convert_io_type_to_otw_type(
    const void *io_buff, const io_type_t &io_type,
    void *otw_buff, const otw_type_t &otw_type,
    size_t num_samps
){
    switch(get_pred(io_type, otw_type)){
    #for $pred in range(2**$ph.nbits)
    case $pred:
        #set $out_type = $ph.get_dev_type($pred)
        #set $in_type = $ph.get_host_type($pred)
        #set $converter = '_'.join([$in_type, 'to', $out_type, $ph.get_swap_type($pred)])
        $(converter)((const $(in_type)_t *)io_buff, ($(out_type)_t *)otw_buff, num_samps);
        break;
    #end for
    }
}

/***********************************************************************
 * Convert device type to host type
 **********************************************************************/
void transport::convert_otw_type_to_io_type(
    const void *otw_buff, const otw_type_t &otw_type,
    void *io_buff, const io_type_t &io_type,
    size_t num_samps
){
    switch(get_pred(io_type, otw_type)){
    #for $pred in range(4)
    case $pred:
        #set $out_type = $ph.get_host_type($pred)
        #set $in_type = $ph.get_dev_type($pred)
        #set $converter = '_'.join([$in_type, 'to', $out_type, $ph.get_swap_type($pred)])
        $(converter)((const $(in_type)_t *)otw_buff, ($(out_type)_t *)io_buff, num_samps);
        break;
    #end for
    }
}

"""

def parse_tmpl(_tmpl_text, **kwargs):
    from Cheetah.Template import Template
    return str(Template(_tmpl_text, kwargs))

class ph:
    bswap_p  = 0b00001
    nswap_p  = 0b00000
    item32_p = 0b00000
    sc16_p   = 0b00010
    fc32_p   = 0b00000

    nbits = 2 #see above

    @staticmethod
    def has(pred, flag): return (pred & flag) == flag

    @staticmethod
    def get_swap_type(pred):
        if ph.has(pred, ph.bswap_p): return 'bswap'
        if ph.has(pred, ph.nswap_p): return 'nswap'
        raise NotImplementedError

    @staticmethod
    def get_dev_type(pred):
        if ph.has(pred, ph.item32_p): return 'item32'
        raise NotImplementedError

    @staticmethod
    def get_host_type(pred):
        if ph.has(pred, ph.sc16_p): return 'sc16'
        if ph.has(pred, ph.fc32_p): return 'fc32'
        raise NotImplementedError

if __name__ == '__main__':
    import sys
    open(sys.argv[1], 'w').write(parse_tmpl(TMPL_TEXT, file=__file__, ph=ph))
