#!/usr/bin/env python
"""
Generate the function list for the basic NocScript functions
"""

import re
import sys
from Cheetah.Template import Template

#############################################################################
# This is the interesting part: Add new functions in here
#
# End of functions is delimited by s/^}/, so take care with
# the indents!
FUNCTION_LIST = """
### Math
INT ADD(INT, INT)
{
    return expression_literal($args[0] + $args[1]);
}

DOUBLE ADD(DOUBLE, DOUBLE)
{
    return expression_literal($args[0] + $args[1]);
}

DOUBLE MULT(DOUBLE, DOUBLE)
{
    return expression_literal($args[0] * $args[1]);
}

INT MULT(INT, INT)
{
    return expression_literal($args[0] * $args[1]);
}

BOOL LE(INT, INT)
{
    return expression_literal(bool($args[0] <= $args[1]));
}

BOOL GE(INT, INT)
{
    return expression_literal(bool($args[0] >= $args[1]));
}

BOOL LT(INT, INT)
{
    return expression_literal(bool($args[0] < $args[1]));
}

BOOL GT(INT, INT)
{
    return expression_literal(bool($args[0] > $args[1]));
}

BOOL LT(DOUBLE, DOUBLE)
{
    return expression_literal(bool($args[0] < $args[1]));
}

BOOL GT(DOUBLE, DOUBLE)
{
    return expression_literal(bool($args[0] > $args[1]));
}

INT IROUND(DOUBLE)
{
    return expression_literal(int(boost::math::iround($args[0])));
}

BOOL IS_PWR_OF_2(INT)
{
    if ($args[0] < 0) return $FALSE;
    int i = $args[0];
    while ( (i & 1) == 0 and (i > 1) ) {
        i >>= 1;
    }
    return expression_literal(bool(i == 1));
}

INT LOG2(INT)
{
    if ($args[0] < 0) {
        throw uhd::runtime_error(str(
            boost::format("In NoCScript function ${func_name}: Cannot calculate log2() of negative number.")
        ));
    }

    int power_value = $args[0];
    int log2_value = 0;
    while ( (power_value & 1) == 0 and (power_value > 1) ) {
        power_value >>= 1;
        log2_value++;
    }
    return expression_literal(log2_value);
}

BOOL EQUAL(INT, INT)
{
    return expression_literal(bool($args[0] == $args[1]));
}

BOOL EQUAL(DOUBLE, DOUBLE)
{
    return expression_literal(bool($args[0] == $args[1]));
}

BOOL EQUAL(STRING, STRING)
{
    return expression_literal(bool($args[0] == $args[1]));
}

### Boolean Logic
BOOL XOR(BOOL, BOOL)
{
    return expression_literal($args[0] xor $args[1]);
}

BOOL NOT(BOOL)
{
    return expression_literal(not $args[0]);
}

BOOL TRUE()
{
    return $TRUE;
}

BOOL FALSE()
{
    return $FALSE;
}

### Conditional Execution
BOOL IF(BOOL, BOOL)
{
    if ($args[0]) {
        $args[1];
        return expression_literal(true);
    }
    return expression_literal(false);
}

BOOL IF_ELSE(BOOL, BOOL, BOOL)
{
    if ($args[0]) {
        $args[1];
        return expression_literal(true);
    } else {
        $args[2];
    }
    return expression_literal(false);
}

### Execution Control
BOOL SLEEP(DOUBLE)
{
    int ms = $args[0] * 1000;
    boost::this_thread::sleep(boost::posix_time::milliseconds(ms));
    return expression_literal(true);
}
"""
# End of interesting part. The rest will take this and turn into a C++
# header file.
#############################################################################

HEADER = """//
// Copyright 2015 Ettus Research LLC
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

/****************************************************************************
 * This file is autogenerated! Any manual changes in here will be
 * overwritten by calling nocscript_gen_basic_funcs.py!
 ***************************************************************************/

#include "expression.hpp"
#include "function_table.hpp"
#include <uhd/exception.hpp>
#include <boost/format.hpp>
#include <boost/assign/list_of.hpp>
#include <boost/math/special_functions/round.hpp>
#include <boost/thread/thread.hpp>

#ifndef INCLUDED_LIBUHD_RFNOC_NOCSCRIPT_BASICFUNCS_HPP
#define INCLUDED_LIBUHD_RFNOC_NOCSCRIPT_BASICFUNCS_HPP

namespace uhd { namespace rfnoc { namespace nocscript {
"""

FOOTER="""
}}} /* namespace uhd::rfnoc::nocscript */

#endif /* INCLUDED_LIBUHD_RFNOC_NOCSCRIPT_BASICFUNCS_HPP */
"""

FUNC_TEMPLATE = """
expression_literal {NAME}(expression_container::expr_list_type &{ARGS})
{BODY}
"""

REGISTER_MACRO_TEMPLATE = """\#define _REGISTER_ALL_FUNCS()$registry
"""

REGISTER_COMMANDS_TEMPLATE = """
    #if len($arglist):
    expression_function::argtype_list_type ${func_name}_args = boost::assign::list_of
    #for $this_type in $arglist
        (expression::TYPE_${this_type})
    #end for
    ;
    #else
    expression_function::argtype_list_type ${func_name}_args;
    #end if
    register_function(
            "${name}",
            boost::bind(&${func_name}, _1),
            expression::TYPE_${retval},
            ${func_name}_args
    );"""

def parse_tmpl(_tmpl_text, **kwargs):
    return str(Template(_tmpl_text, kwargs))

def make_cxx_func_name(func_dict):
    """
    Creates a unique C++ function name from a function description
    """
    return "{name}__{retval}__{arglist}".format(
        name=func_dict['name'],
        retval=func_dict['retval'],
        arglist="_".join(func_dict['arglist'])
    )

def make_cxx_func_body(func_dict):
    """
    Formats the function body properly
    """
    type_lookup_methods = {
            'INT': 'get_int',
            'DOUBLE': 'get_double',
            'BOOL': 'get_bool',
            'STRING': 'get_string',
    }
    args_lookup = []
    for idx, arg_type in enumerate(func_dict['arglist']):
        args_lookup.append("args[{idx}]->eval().{getter}()".format(idx=idx, getter=type_lookup_methods[arg_type]))
    return parse_tmpl(
        func_dict['body'],
        args=args_lookup,
        FALSE='expression_literal(false)',
        TRUE='expression_literal(true)',
        **func_dict
    )

def prep_function_list():
    """
    - Remove all comments
    - Split the function list into individual functions
    - Split the functions into return value, name, argument list and body
    """
    comment_remove_re = re.compile(r'^\s*#.*$', flags=re.MULTILINE)
    func_list_wo_comments = comment_remove_re.sub('', FUNCTION_LIST)
    func_splitter_re = re.compile(r'(?<=^})\s*$', flags=re.MULTILINE)
    func_list_split = func_splitter_re.split(func_list_wo_comments)
    func_list_split = [x.strip() for x in func_list_split if len(x.strip())]
    func_list = []
    for func in func_list_split:
        split_regex = r'(?P<retval>[A-Z][A-Z0-9_]*)\s+(?P<funcname>[A-Z][A-Z0-9_]*)\s*\((?P<arglist>[^\)]*)\)\s*(?P<funcbody>^{.*)'
        split_re = re.compile(split_regex, flags=re.MULTILINE|re.DOTALL)
        mo = split_re.match(func)
        func_dict = {
            'name': mo.group('funcname'),
            'retval': mo.group('retval'),
            'arglist': [x.strip() for x in mo.group('arglist').split(',') if len(x.strip())],
            'body': mo.group('funcbody'),
        }
        func_dict['func_name'] = make_cxx_func_name(func_dict)
        func_list.append(func_dict)
    return func_list

def write_function_header():
    func_list = prep_function_list()
    # Step 1: Write the prototypes
    func_prototypes = ''
    registry_commands = ''
    for func in func_list:
        func_prototypes += FUNC_TEMPLATE.format(
            NAME=func['func_name'],
            BODY=make_cxx_func_body(func),
            ARGS="args" if len(func['arglist']) else ""
        )
        registry_commands += parse_tmpl(
                REGISTER_COMMANDS_TEMPLATE,
                **func
        )
    # Step 2: Write the registry process
    register_func = parse_tmpl(REGISTER_MACRO_TEMPLATE, registry=registry_commands)
    register_func = register_func.replace('\n', ' \\\n')

    # Final step: Join parts and write to file
    full_file = "\n".join((
            HEADER,
            func_prototypes,
            register_func,
            FOOTER
    ))
    open(sys.argv[1], 'w').write(full_file)

def main():
    write_function_header()

if __name__ == "__main__":
    main()
