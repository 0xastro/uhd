

/***********************************************************************
 * This file was generated by gen_adf4360_regs.py on Tue Apr  6 18:40:51 2010
 **********************************************************************/

#ifndef INCLUDED_ADF4360_REGS_HPP
#define INCLUDED_ADF4360_REGS_HPP

#include <boost/cstdint.hpp>

struct adf4360_regs_t{
    enum core_power_level_t{
        CORE_POWER_LEVEL_5MA = 0,
        CORE_POWER_LEVEL_10MA = 1,
        CORE_POWER_LEVEL_15MA = 2,
        CORE_POWER_LEVEL_20MA = 3
    } core_power_level;
    enum counter_reset_t{
        COUNTER_RESET_NORMAL = 0,
        COUNTER_RESET_RESET = 1
    } counter_reset;
    enum muxout_control_t{
        MUXOUT_CONTROL_3STATE = 0,
        MUXOUT_CONTROL_DLD = 1,
        MUXOUT_CONTROL_NDIV = 2,
        MUXOUT_CONTROL_DVDD = 3,
        MUXOUT_CONTROL_RDIV = 4,
        MUXOUT_CONTROL_NCHAN_OD_LD = 5,
        MUXOUT_CONTROL_SDO = 6,
        MUXOUT_CONTROL_DGND = 7
    } muxout_control;
    enum phase_detector_polarity_t{
        PHASE_DETECTOR_POLARITY_NEG = 0,
        PHASE_DETECTOR_POLARITY_POS = 1
    } phase_detector_polarity;
    enum cp_three_state_t{
        CP_THREE_STATE_NORMAL = 0,
        CP_THREE_STATE_3STATE = 1
    } cp_three_state;
    enum cp_gain_0_t{
        CP_GAIN_0_SET1 = 0,
        CP_GAIN_0_SET2 = 1
    } cp_gain_0;
    enum mute_till_ld_t{
        MUTE_TILL_LD_DIS = 0,
        MUTE_TILL_LD_ENB = 1
    } mute_till_ld;
    enum output_power_level_t{
        OUTPUT_POWER_LEVEL_3_5MA = 0,
        OUTPUT_POWER_LEVEL_5_0MA = 1,
        OUTPUT_POWER_LEVEL_7_5MA = 2,
        OUTPUT_POWER_LEVEL_11_0MA = 3
    } output_power_level;
    enum current_setting1_t{
        CURRENT_SETTING1_0_31 = 0,
        CURRENT_SETTING1_0_62 = 1,
        CURRENT_SETTING1_0_93 = 2,
        CURRENT_SETTING1_1_25 = 3,
        CURRENT_SETTING1_1_56 = 4,
        CURRENT_SETTING1_1_87 = 5,
        CURRENT_SETTING1_2_18 = 6,
        CURRENT_SETTING1_2_50 = 7
    } current_setting1;
    enum current_setting2_t{
        CURRENT_SETTING2_0_31 = 0,
        CURRENT_SETTING2_0_62 = 1,
        CURRENT_SETTING2_0_93 = 2,
        CURRENT_SETTING2_1_25 = 3,
        CURRENT_SETTING2_1_56 = 4,
        CURRENT_SETTING2_1_87 = 5,
        CURRENT_SETTING2_2_18 = 6,
        CURRENT_SETTING2_2_50 = 7
    } current_setting2;
    enum power_down_t{
        POWER_DOWN_NORMAL_OP = 0,
        POWER_DOWN_ASYNC_PD = 1,
        POWER_DOWN_SYNC_PD = 3
    } power_down;
    enum prescaler_value_t{
        PRESCALER_VALUE_8_9 = 0,
        PRESCALER_VALUE_16_17 = 1,
        PRESCALER_VALUE_32_33 = 2
    } prescaler_value;
    boost::uint8_t a_counter;
    boost::uint16_t b_counter;
    enum cp_gain_1_t{
        CP_GAIN_1_SET1 = 0,
        CP_GAIN_1_SET2 = 1
    } cp_gain_1;
    enum divide_by_2_output_t{
        DIVIDE_BY_2_OUTPUT_FUND = 0,
        DIVIDE_BY_2_OUTPUT_DIV2 = 1
    } divide_by_2_output;
    enum divide_by_2_prescaler_t{
        DIVIDE_BY_2_PRESCALER_FUND = 0,
        DIVIDE_BY_2_PRESCALER_DIV2 = 1
    } divide_by_2_prescaler;
    boost::uint16_t r_counter;
    enum ablpw_t{
        ABLPW_3_0NS = 0,
        ABLPW_1_3NS = 1,
        ABLPW_6_0NS = 2
    } ablpw;
    enum lock_detect_precision_t{
        LOCK_DETECT_PRECISION_3CYCLES = 0,
        LOCK_DETECT_PRECISION_5CYCLES = 1
    } lock_detect_precision;
    boost::uint8_t test_mode_bit;
    enum band_select_clock_div_t{
        BAND_SELECT_CLOCK_DIV_1 = 0,
        BAND_SELECT_CLOCK_DIV_2 = 1,
        BAND_SELECT_CLOCK_DIV_4 = 2,
        BAND_SELECT_CLOCK_DIV_8 = 3
    } band_select_clock_div;

    adf4360_regs_t(void){
        core_power_level = CORE_POWER_LEVEL_5MA;
        counter_reset = COUNTER_RESET_NORMAL;
        muxout_control = MUXOUT_CONTROL_3STATE;
        phase_detector_polarity = PHASE_DETECTOR_POLARITY_NEG;
        cp_three_state = CP_THREE_STATE_NORMAL;
        cp_gain_0 = CP_GAIN_0_SET1;
        mute_till_ld = MUTE_TILL_LD_DIS;
        output_power_level = OUTPUT_POWER_LEVEL_3_5MA;
        current_setting1 = CURRENT_SETTING1_0_31;
        current_setting2 = CURRENT_SETTING2_0_31;
        power_down = POWER_DOWN_NORMAL_OP;
        prescaler_value = PRESCALER_VALUE_8_9;
        a_counter = 0;
        b_counter = 0;
        cp_gain_1 = CP_GAIN_1_SET1;
        divide_by_2_output = DIVIDE_BY_2_OUTPUT_FUND;
        divide_by_2_prescaler = DIVIDE_BY_2_PRESCALER_FUND;
        r_counter = 0;
        ablpw = ABLPW_3_0NS;
        lock_detect_precision = LOCK_DETECT_PRECISION_3CYCLES;
        test_mode_bit = 0;
        band_select_clock_div = BAND_SELECT_CLOCK_DIV_1;
    }

    enum addr_t{
        ADDR_CONTROL = 0,
        ADDR_NCOUNTER = 2,
        ADDR_RCOUNTER = 1
    };

    boost::uint32_t get_reg(addr_t addr){
        boost::uint32_t reg = addr & 0x3;
        switch(addr){
        case 0:
            reg |= (boost::uint32_t(core_power_level) & 0x3) << 2;
            reg |= (boost::uint32_t(counter_reset) & 0x1) << 4;
            reg |= (boost::uint32_t(muxout_control) & 0x7) << 5;
            reg |= (boost::uint32_t(phase_detector_polarity) & 0x1) << 8;
            reg |= (boost::uint32_t(cp_three_state) & 0x1) << 9;
            reg |= (boost::uint32_t(cp_gain_0) & 0x1) << 10;
            reg |= (boost::uint32_t(mute_till_ld) & 0x1) << 11;
            reg |= (boost::uint32_t(output_power_level) & 0x3) << 12;
            reg |= (boost::uint32_t(current_setting1) & 0x7) << 14;
            reg |= (boost::uint32_t(current_setting2) & 0x7) << 17;
            reg |= (boost::uint32_t(power_down) & 0x3) << 20;
            reg |= (boost::uint32_t(prescaler_value) & 0x3) << 22;
            break;
        case 1:
            reg |= (boost::uint32_t(r_counter) & 0x3fff) << 2;
            reg |= (boost::uint32_t(ablpw) & 0x3) << 16;
            reg |= (boost::uint32_t(lock_detect_precision) & 0x1) << 18;
            reg |= (boost::uint32_t(test_mode_bit) & 0x1) << 19;
            reg |= (boost::uint32_t(band_select_clock_div) & 0x3) << 20;
            break;
        case 2:
            reg |= (boost::uint32_t(a_counter) & 0x1f) << 2;
            reg |= (boost::uint32_t(b_counter) & 0x1fff) << 8;
            reg |= (boost::uint32_t(cp_gain_1) & 0x1) << 21;
            reg |= (boost::uint32_t(divide_by_2_output) & 0x1) << 22;
            reg |= (boost::uint32_t(divide_by_2_prescaler) & 0x1) << 23;
            break;
        }
        return reg;
    }
};

#endif /* INCLUDED_ADF4360_REGS_HPP */

